"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("@stryker-mutator/util");
const ChildProcessCrashedError_1 = require("../child-proxy/ChildProcessCrashedError");
const ChildProcessProxy_1 = require("../child-proxy/ChildProcessProxy");
const ChildProcessTestRunnerWorker_1 = require("./ChildProcessTestRunnerWorker");
const MAX_WAIT_FOR_DISPOSE = 2000;
/**
 * Runs the given test runner in a child process and forwards reports about test results
 */
class ChildProcessTestRunnerDecorator {
    constructor(options, sandboxWorkingDirectory, loggingContext) {
        this.worker = ChildProcessProxy_1.default.create(require.resolve(`./${ChildProcessTestRunnerWorker_1.ChildProcessTestRunnerWorker.name}`), loggingContext, options, {}, sandboxWorkingDirectory, ChildProcessTestRunnerWorker_1.ChildProcessTestRunnerWorker);
    }
    init() {
        return this.worker.proxy.init();
    }
    dryRun(options) {
        return this.worker.proxy.dryRun(options);
    }
    mutantRun(options) {
        return this.worker.proxy.mutantRun(options);
    }
    async dispose() {
        await util_1.ExpirableTask.timeout(
        // First let the inner test runner dispose
        this.worker.proxy.dispose().catch((error) => {
            // It's OK if the child process is already down.
            if (!(error instanceof ChildProcessCrashedError_1.default)) {
                throw error;
            }
        }), 
        // ... but don't wait forever on that
        MAX_WAIT_FOR_DISPOSE);
        // After that, dispose the child process itself
        await this.worker.dispose();
    }
}
exports.default = ChildProcessTestRunnerDecorator;
//# sourceMappingURL=ChildProcessTestRunnerDecorator.js.map